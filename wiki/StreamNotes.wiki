#summary Luke's notes on RTMP streaming

== Introduction ==

Notes of different parts of RTMP and streaming. Random order at the moment.

=== Stream Bytes Read Packet === 

Stream bytes read packets are sent by the client or server when receiving data. When the client is publishing the server must send these packets at regular intervals otherwise the client will close the connection. I think the default for the flash player is to send every 125000 bytes. 

=== Client & Server Bandwidth Packet === 

There are two types for setting bandwidth for upstream and downstream. 

=== Net Status Events === 

The server sends back status events that the client listens to. You can think of these as a standard layer over the top of the basic RTMP protocol. They do not effect media output on the client directly. For the full list see: ems.hrl.

TODO: describe structure.

=== Pings (Protocol Signals) Packets === 

Historically we called them pings, since the first one we discovered was like the standard ping. However in addition to this they also signal the stream state and buffer length. Not all the types are known.

=== App Commands === 

Clients call methods when they connect and disconnect. But we cannot rely on disconnect being called since sometimes (in the case of dropped network connection) disconnect will not be called. In order to detect dropped connections we can ping the clients at regular intervals to check they are still responding.

{{{

  * connect

  * disconnect

}}}

TODO: connect parms

Most of the other commands are stream related (see below), any thing else, is a custom call using NC.call to the application.

=== Stream Commands === 

Stream commands (play, pause, seek, etc) are sent to the application. It's the applications responsibility to pass these onto the stream. Think of this as a chain of responsibility. e.g. 

RTMP => App [=> PlayList] [=> ServerStream [=> StreamProvider]]

legend: => message passing, [optional]

{{{

createStream() % reserve a stream id (next in sequence)
  -> nextStreamID()

deleteStream(StreamID) % remove the stream and release id

%% following funs know stream id from header

publish(Name, Mode) % modes: record, append, live 

releaseStream(Name) % release a stream (assumed for published streams)

play(Name, Position, Length, FlagFlushPlayList) % all apart from name optional

pause(Flag, Position) % toggle pause, option jump to position

seek(Position) % jump to nearest keyframe

receiveAudio(Flag) % toggle audio

receiveVideo(Flag) % toggle video

closeStream() pass command to stream

}}}

=== Stream Commands Responses ===

I'm just using a made up notation for now, but we can switch to erlang.

TODO: error responses.
TODO: check using debug proxy.

pause

{{{
signal(PING_STREAM_PLAYBUFFER_CLEAR)
status(NS_PAUSE_NOTIFY)
}}}

resume

{{{
signal(PING_STREAM_RESET)
signal(PING_STREAM_CLEAR)
status(NS_UNPAUSE_NOTIFY)
}}}


play

{{{
status(NS_PLAY_RESET)
status(NS_PLAY_START)
frame(KeyFrame)
}}}

stop 

{{{
signal(PING_STREAM_PLAYBUFFER_CLEAR)
status(NS_PLAY_COMPLETE) if end of playlist
status(NS_PLAY_STOP)
}}}

seek

{{{
signal(PING_STREAM_PLAYBUFFER_CLEAR)
signal(PING_STREAM_RESET)
signal(PING_STREAM_CLEAR)
status(NS_SEEK_NOTIFY)
status(NS_PLAY_START)
frame(KeyFrame) or frame(BlankAudio)
}}}


