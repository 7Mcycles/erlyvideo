#summary Notes on architecture.

== Design Ideas ==

Another one of my rather messy design idea documents. This time I have spent quite a bit of time trying to get my head to see the world in an Elrang way. Everything is a process, no shared memory, pure message passing etc. I have tried to break the system down into black boxes. 

=== Diagrams ===

[http://erlyvideo.googlecode.com/svn/wiki/images/on_demand_streaming.jpg]

[http://erlyvideo.googlecode.com/svn/wiki/images/stream_recording.jpg]

[http://erlyvideo.googlecode.com/svn/wiki/images/live_streaming.jpg]

=== Binary Efficiency ===

Efficient use of binaries is critical to the performance of the server. Erlang does not create a new binary for every variable pointing to it, instead it creates a reference and increments a counter. The binary data is stored on a separate heap. Thus there should only need to be one copy of each binary per node. This means providing we don't chop up the binary we can pass it efficiently around the node. The binary will be garbage collected when there are no more references to it. Of course when it comes to passing the binary between processes on different nodes the binary must be sent over the wire. I'm assuming that if you send the same binary in separate messages between nodes that is passed each time. This assumption should be tested, since if its not the case then the design may change. For the sake of this design I assume its efficient to minimize the number of times a binary is passed between nodes. Reading from memory on the local node should always be the preferred route. 

=== Stream FSM ===

In the current design we have a FSM for the clients connection. This deals primarily with the state of the RTMP protocol, namely the transition from the handshake to the connected active state. It also controls playing and recording of streams. IMHO this lumps to separate state machines together. I suggest we separate out the RTMP state and create a separate process to handle the stream with its own state machine. The state transitions would be along the lines of: ready -> playing, playing -> paused, paused -> playing, playing -> seeking, seeking -> playing, playing -> stopped.. etc. There could be separate states for playing of on demand media and receiving of a live broadcast. Since with a live you cannot seek, pause, etc.

=== Media Broker ===

When a stream needs to access a media object, it sends its request to the Media Broker. The broker gets a list of the possible sources and works out the cost of access for each source. It then chooses the cheapest (most efficient) option. The cost of access is based on the following formula.

# It costs more of read media from disk.
# It costs more to access media from another node.
# The cost of access on any node depends on that nodes resource usage. 

Using this sort of formula we should be able to design the cluster to adapt to changing load with a bit of tweaking.

Another possible action of the broker would be to refuse access via this node, and issue a redirect to another node. AFAIK this is available in the next version of FMS so should be possible to handle at the RTMP level. This would help spread the load across the cluster in situations where the cluster is not behind a load balancer. 

=== (Cached) Media Source === 

A media source can be thought of as a process which caches part or all of a media object. A media source has the following properties.

# Maintains an index of frame types, offsets, and positions.
# Maintains a cache of frames in an array.
# Random access to frames. 
# Supports reading of ranges.
# Supports actions such as nearest keyframe.
# Can be chained to a media reader or another media source.
# Can be expired after a certain period of inactivity to free up memory.

=== Media Reader and Media Writer ===

Components which read and write media objects to storage.
Convert between the media file format and media frames.
Can be disk or HTTP versions. 

=== Media Frame === 

Binary is already chunked.

=== Broadcast Manager === 

=== Broadcast Source and Broadcast Repeater ===

=== Broadcast Archiver ===

Connects to a broadcast and saves it

